多数现代计算机系统以及绝大多数多核芯片都支持硬件共享内存。在这种共享内存的系统中，每个处理器的核心可以读写同一个共享的地址空间。这些设计出发点是为获得不同的好处，如高性能，低功耗以及低成本。当然，在提供这些优点的同时，如果不能保证正确性，这些好处就毫无价值可言。共享内存的正确性看起来就像挥挥手一样简单，但实际上，即便是在定义共享内存系统正确性本身也有很多细节问题需要考虑，同样在设计一个正确的共享内存实现方案的时候，存在许多细枝末节的边缘情况（corner case）。此外，这些细微的问题在硬件实现时必须被完全掌握理解，因为硬件bug的修复成本极其昂贵。甚至学术界的人也应该掌握这些细节，这样他们提出的设计方案才更可能正常工作。

对于共享内存的正确性而言，将其划分为两个子问题来讨论会大有裨益：consistency和coherence。计算机系统本身没有被要求做此区分，但这样做对分治复杂的问题很有帮助，并且在许多真实的共享内存实现方案上，这种划分普遍存在。

consistency（内存一致性-memory consistency，内存一致性模型-memory consistency model或指内存模型memory model）的任务是定义共享内存的正确性。一致性定义提供了store和load（或叫内存的读和写）操作的规则，以及这些操作如何运作于物理内存之上。理想情况下，一致性的定义应该是简单易懂的。但实际上定义共享内存正确行为的含义要比定义正确的行为（例如一个单线程的处理器核中的正确行为）有更多细节问题。对于一个单独的处理器核来讲，正确性标准要将一个正确结果和许多非正确的备选行为中之间划分开来。这是由于处理器的体系架构强制要求一个线程的执行过程要将给定的输入状态转换到一个确定的输出状态，即便是在支持乱序执行的核上也是如此。但共享内存一致性模型关心的是多个线程的load和store操作，并且通常允许许多正确的执行过程同时不允许很多（更多）不正确的执行过程。多个正确的执行过程得以发生是因为ISA允许多个线程并发执行，不同线程里的指令很有可能存在许多合法的交织运行。大量正确执行过程使得先前只用简单地确定单个执行过程是否正确的事情变得复杂起来。尽管如此，为了实现共享内存以及正确编写使用共享内存的程序，consistency的知识必须被掌握。

和consistency不同，coherence（或叫cache coherence）既不对软件可见也不要求可见。然而作为支持内存一致性模型的组成部分，大多数的共享内存系统实现了一个cache一致性协议。coherence目的是要让共享内存系统的cache就像单核系统中的cache一样在功能上不对外可见。正确的cache一致性保证了程序员不能通过分析加载和存储(loads and stores)的结果来确定系统是否有cache，cache在什么位置。这是因为正确的cache一致性确保了cache绝不会启用新的或不同的功能行为（程序员仍然可以通过使用时间信息来推断出cache可能的结构）。

在大多数系统中，在提供consistency机制时，coherence协议扮演着很重要的角色。因此本入门文章中，consistency作为第一个重要的主题先提出，在第二章中会对cache一致性进行简单的介绍。这一章的目的是为了解释清楚cache一致性，以便理解consistency模型和coherent cache之间的交互，但并不会深入到具体的cache一致性协议或实现上，这些内容会推迟到入门文章中第二部分的第六到第九章。在第二章中，我们会使用单写者-多读者（single-writer–multiple-reader - SWMR）不变性来定义coherence。SWMR要求在任一给定时间，一个内存地址要么被缓存在一个cache中用于写（以及读），要么是被缓存在0个到多个cache中用于读。


## 1.1 CONSISTENCY（也称Memory Consistency， Memory Consistency Model，Memory Model）
内存一致性模型通过加载和存储（内存的读和写）定义正确的共享内存行为，不涉及cache和cache coherence相关内容。为了搞清楚为何我们需要内存一致性模型，我们以一个真实世界的案例来说明：有一所大学会在线上发布课程的日程安排。假设《计算机体系架构》这门课原来定在152号教室进行。在课程开始的前一天，登记员决定把课程移到252号教室进行。登记员发送电子邮件给网站管理员要求更新线上的日程，几分钟后，登记员发送了一个文字消息给所有已注册课程的学生，提醒它们检查最新的日程。我们不难想象这种场景：如果网站管理员太忙，没能及时更新网站信息，一个勤奋的学生收到了文字消息后，立刻去查看在线日程，他看到的仍然是老的152号教室。即便是在线日程最终被更新到了252号教室，并且登记员按照正确的顺序执行了"写"操作，这名勤奋的学生看到的信息发生在不同的顺序中，因此去了错误的教室。内存一致性模型会定义这种行为到底是正确的（如果是正确的那么用户为了获得期望的结果是否要必须采取其它行动）或是错误的（这种情况下系统必须阻止这些重排序）。

虽然这个假的例子中使用了多种媒介，类似的行为在共享内存硬件上也会出现，这种系统包含多个乱序执行的处理器核，write buffer，预取功能以及多个cache bank。因此，我们需要定义共享内存正确性概念，即哪些共享内存行为被允许，这样程序员能够明白期望的结果是什么，硬件实现者能够知道有哪些限制。
共享内存正确性通过内存一致性模型或简称内存模型来指定。内存模型指定了使用共享内存的多线程程序执行中所允许的行为。对一个使用特定输入数据，正在执行的多线程程序来说，内存模型指定了动态加载（loads）动作可以返回什么值，以及内存最终变化到的各种可能的状态。和单线程执行不同，多个正确的行为都是被允许的，因此内存一致性模型并非是显而易见地容易理解。

第三章介绍了内存一致性模型的概念，并且提出了顺序一致性（sequntial consistency - SC） - 最严格并且最直观的内存模型。这个章节以指定共享内存行为的需求出发，精确地定义了什么是内存一致性模型。然后会进入到直观的SC模型，SC模型表述了一个多线程的运行过程应该看起来像是每个线程的顺序执行的交织执行过程，就好像这些线程在一个单核处理器上分时复用一样。在直觉认知之上，这一章形式化了SC并且探索了带cache一致性的SC的实现方法，简单的和激进的方式都会描述，以MIPS R10000的案例结束。

第四章聚焦于X86和SPARC系统实现的内存一致性模型上。这个一致性模型，叫做TSO（total store order），这个模型是受到使用基于FIFO的write buffer（在写结果到cache前用来保存已提交存储操作的结果）的需求所驱动的。这个优化破坏了SC模型，但却保证了足够的性能提升来促使体系架构去定义TSO。在这一章中，会展示如何从SC的形式化中去形式化TSO，TSO如何影响实现方案，以及SC和TSO的对比。

最后，第五章介绍"松散"（relaxed）或叫"弱"(weak)内存一致性模型。通过介绍强内存模型（strong model）的大多数内存排序都并非必要作为引子，来引出这些模型的初衷。如果一个线程更新了10个数据项，然后更新一个同步标记，程序员通常不需要关注数据项是否按照顺序更新，只需要知道在标记被更新前，所有数据项都被更新到了。松散模型关注这类增加的顺序灵活性来获得更高的性能或更简单的实现。在说明了松散模型的初衷后，这个章节开发了一个松散一致性模型的例子，叫做XC，在XC中程序员仅在主动请求的时候进行内存顺序操作，通过一个FENCE指令来实现（例如，在最后一个数据更新后，写同步标记前使用一个FENCE指令）。这个章节接着扩展了前两章的形式化描述来解释XC并且讨论了如何实现XC（考虑了core与coherence协议之间的重排序）。·接着会讨论一种方法，使用此方法会使得程序员能够避免直接考虑松散模型:如果加入足够多的FENCE来保证程序是无竞争的（Data-race free - DRF），那么最松散的模型看起来类似SC。使用"SC for DRF"，程序员能够同时获得SC的（相对）简单的正确性模型和XC的（相对）高性能。对于想要更深地探讨的人来说，这个章节以区分aquire和release、讨论写原子性和因果关系、商用模型（包含IBM Power案例学习）、高级语言模型（JAVA和C++）等内容结束。

回到前面举例的真实世界的课程表一致性问题上，我们能够观察到一个email系统，真人web管理员以及一个文本消息系统的组合表示出了一个极其weak的一致性模型。为避免勤奋的学生走进错误的教室，大学的登记处需要在发送email后，执行一个FENCE操作来保证在发送文字消息前在线课程表已经被更新了。


## 1.2 COHERENCE（也叫 Cache Coherence）
除非多加小心，<u>否则如果多个actor（例如多个core）对一个数据项的多份拷贝（例如在多个cache里）进行访问，并且至少有一个访问是写操作，一致性问题就会产生</u>。我们以内存一致性中的相似的例子来说明。一个学生查看在线课程表，看到《计算机体系架构》这门课在152号教室进行（读取数据项），并且将此信息拷贝到了她自己的笔记本上（缓存数据项）。紧接着，大学登记处决定将课程换到252号教室进行，并且更新了在线课程表（写入数据项）。这个学生对于该数据项的拷贝就过时了，这就发生了不一致的情况。如果她跑到152号教室的话会找不到她的班级。计算机世界中不一致性例子，但不包括计算机体系架构本身，有过时的web缓存以及程序员使用了未更新的代码库。

使用一个一致性协议可以避免访问过时的数据（不一致行为）问题，这个协议是系统内分散的actor集合所实现的一套规则。一致性协议有多种变体，但都遵循一些特定主题，第六到第九章中会进行说明。

第六章呈现了cache一致性协议大框图并且为后续讲解特定一致性协议的章节进行了铺垫。这个章节涵盖了大多数一致性协议所共有的问题，包括cache控制器和内存控制器的分布式操作，常见的MOESI一致性状态机：modified(M)，owned(O),exclusive(E),shared(S), 以及invalid(I)。这一章会使用表格驱动方法来展示同时带有稳定的(如MOESI)和临时状态的协议。临时状态（transient state）在实际实现中是必需的，因为现代的系统中很少有允许从一个稳定状态原子地转换到另一个状态的情况（例如，Invalid状态中的read miss会花费一些等待数据响应的时间，随后才能进入到Shared状态）。一致性协议中很多真实存在的复杂性都隐藏在瞬时状态里，就像处理器核的有很多复杂性都隐藏在微架构状态中一样。

第七章涵盖了snooping cache一致性协议，这个协议统治了商业市场一直到近期。snooping协议比较简单。当发生了一个cache miss， 一个core的cache控制器在共享总线上广播其请求。共享总线保证所有控制器按照相同顺序观察到所有请求，因此所有控制器能够协调它们独立的、分布式的行为来确保它们维护了一份全局一致的状态。但由于系统可能使用多条总线，并且现代的总线并不会原子地处理请求，使得snooping变得复杂。现代的总线有多个用于仲裁的队列，并且能够发送单播的、被流水线延迟的或乱序的响应。这些全部特性造成了更多的临时一致性状态。第七章以Sun UltraEnterprise E10000和IBM Power5案例学习结束。

第八章讲解directory cache一致性协议，此协议相比于依赖于广播的snooping协议能够适应更多处理器核心数和其它actor的数量。有一个笑话说在计算机科学中所有问题都可以多加一级间接操作来解决。Directory协议就是这个笑话的支持者：一个cache miss从下一级cache（memory）控制器中请求一个内存地址，下一级控制器维护了一个目录用于跟踪哪个cache对应哪个地址。根据请求内存地址的目录项，控制器会发送响应回请求者或者转发请求消息到一个或多个actor，这些actor当前缓存着对应内存地址。每个消息通常含有一个目的地（即不是广播或组播），但从一个稳定的一致性状态转换到另外一种稳定的状态中的多个瞬时一致性状态能够产生多个消息传播到系统中各个actor。这个章节以一个基础的directory协议展开，随后将它提炼，涉及处理MOESI状态E和O，分布式目录，更少的请求停顿，近似的目录项表示等等内容。此章节中也会探索目录本身的涉及，包含目录缓存技术。这个章节以老旧的SGI Origin 2000和较新的AMD HyperTransport， HyperTransport Assit以及Intel QuickPath Interconnect（QPI）案例学习结尾。
第九章会涉及一些一致性中高级的主题，但不包含所有高级主题。为了便于阐述，前面涉及coherence的章节有意限制为能够解释清原理的最简单的系统模型。第九章会深入到更复杂的系统模型和优化中，重点关注snooping和directory协议都普遍存在的问题。主题涉及指令缓存，多级缓存，写穿（write-through）缓存，TLB，一致性DMA，虚拟缓存和层级化的一致性协议。最后，这个章节会深入性能优化以及直接管理带有token coherence的SWMR不变性。


## 1.3 CONSISTENCY和COHERENCE测试
通过以下测试来看看你是否已经有足够的consistency和coherence的知识了，如果这些问题都难不倒你，那么这本入门对于你来说没必要读。

问题1： 在维护了顺序一致性的系统中，一个核必须按照程序的顺序发起coherence请求。对还是错？（答案在3.8节中）

问题2： 内存一致性模型（memory consistency model）指定了coherence事务的合法顺序。对还是错？（答案在3.8节中）

问题3： 为了执行一个原子读-改-写操作（例如 test-and-set），一个核总是必须和其它核进行通信。对还是错？（答案在3.9节中）

问题4: 在一个多线程的TSO系统中，线程可以bypass write buffer输出的值，无论是哪个线程写入的值。对还是错？（答案在4.4节中）

问题5: 程序员使用高级语言的consistency模型（如JAVA）编写了正确地带同步的代码，就不需要考虑体系架构的内存一致性模型了。对还是错？（答案在5.9节中）

问题6： 在一个MSI snooping协议中，一个cache block只可以处于3种coherence状态中的一种。对还是错？（答案在7.2节中）

问题7： snooping 缓存一致性协议需要多个核在一条总线上进行通信。对还是错？（答案在7.6节中）


## 1.4 本入门不讨论的内容
同步Synchronization。Cohenrence使得cache变得透明。Consistency使得共享内存看起来就像是一个单独的内存模块。无论如何，程序员都可能需要锁、barrier以及其它同步技巧来让程序变得可用。

商用的Relaxed Consistency Model。入门内容不会涵盖所有ARM和PowerPC内存模型的细节，但会描述它们提供了哪些机制来实现内存顺序。
并行编程。入门内容不会讨论并行编程模型，方法论或工具等。