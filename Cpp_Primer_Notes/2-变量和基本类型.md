## 变量和基本类型

### 1. 字节与字

可寻址的最小内存块称为`字节(byte)` ，由八个比特构成

存储的基本单元称为`字(word)` ，由4到8字节构成。

### 2. 带符号类型和无符号类型混用

如果表达式里既有带符号类型，又有无符号类型，**当带符号类型取值为负时会出现异常结果**，这是因为 **带符号数会自动地转换成无符号数**。

### 3. 对象

对象是指一块能存储数据并具有某种类型的内存空间。

### 4. 初始化与赋值

**初始化** 的含义是创建变量时赋予其一个初始值。

**赋值** 的含义是把对象的当前值擦除，以一个新值来替代。  

### 5. 引用

**引用** 为对象起了另外一个名字。

通过将声明符写成`&d` 的形式来定义引用类型，其中d是声明的变量名。

定义引用时，程序把引用和它的初始值绑定在一起。

引用不是对象，是为一个已经存在的对象所起的另外一个名字。（引用即别名）

### 6. 指针

指针也实现了对其他对象的间接访问。

指针与引用相比有很多不同点：

1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期里它可以先后指向几个不同的对象。
2.  指针无需在定义时赋值（初始化）。
3.  指针存放某个对象的地址。
4.  引用的大小是所指向的变量的大小，因为引用只是一个别名而已；指针是指针本身的大小，4个字节。
5. 引用比指针更安全

### 7. 取地址符和解引用符

取地址符`&` 可以取某个对象的地址

解引用符`*` 可以得到指针所指的对象

### 8. 空指针

`nullptr` 为C++11新标准，`NULL`为一个预处理变量，值为0。尽量使用nullptr。

### 9. void* 指针

`void*` 指针是一种特殊类型的指针，可用于存放任意对象的地址，但不能直接操作指针所指的对象。

以`void*` 的视角来看内存空间仅仅是内存空间，没办法访问内存空间中的对象。

### 10. 共享const对象

想在多个文件内共享const对象，必须在变量的定义之前加`extern` 关键字，比如：

```c++
extern const int bufSize = 256;	//file.cpp中的定义和初始化
extern const int bufSize;		//file.h中的全局声明
```

### 11. 常量引用

即对`const`引用，如：

```c++
const int a = 1024;
const int &b = a;	
```

常量引用不能用作修改它所绑定的对象。

### 12. 引用类型必须与所引用对象类型一致

如：

```c++
double a = 3.14;
int &b = a;
```

实际编译器发生了：

```c++
int tmp = (int)a = 3;
int &b = tmp;
```

tmp为临时量变量，引用b绑定的是tmp而不是a，修改b的值a不会改变。所以C++把这种行为归为非法，会报错。

### 13. 常量指针

把`*` 放在`const` 之前说明指针是一个常量。**常量** 指针必须初始化，而且一旦初始化完成，它的值（也就是存放在指针中的地址）就不能载改变了。例如：

```c++
int a = 0;
int *const a_ptr = &a;		//常量指针a_ptr一直指向a，a的值可以改变
const double pi = 3.14;     // const double类型，pi值不可变
const double *const pi_ptr = &pi;	//pi_ptr为指向常量对象的常量指针，pi值不可变
const double *pi_ptr_2 =  &pi;		//指向常量的指针，非常量指针
constexpr int *ptr = nullptr;		//ptr为指向整数的常量指针，因为constexpr把所定义的对象置为了顶层const
```

### 14. 常量表达式

**常量表达式** 是指不会改变并且在编译过程就能得到计算结果的表达式。

允许将变量声明为`constexpr` 类型以便由编译器来验证变量的值是否是一个常量表达式。如：

```c++
constexpr int a = 20;
constexpr int b = a + 1;
```

一般来说，如果认定变量是一个常量表达式，就把它声明成`constexpr` 类型。**常量表达式的值在编译时就得到计算。**

自定义类、IO库、string类不属于**字面值类型** ，不能被定义成`constexpr`  。算数类型、引用和指针属于字面值类型。

### 15. auto类型说明符

用它能让编译器替我们去分析表达式所属的类型。

auto让编译器通过初始值来推算变量的类型。 auto定义的变量必须有初始值。

auto一般会忽略顶层const，保留低层const。

### 16. decltype类型指示符

从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。

```c++
decltype(f()) sum = x;	//f()为表达式，sum为要定义的变量，sum的类型就是f()被调用时返回的类型
```

如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）。
```C++
// Effective Modern C++ 关于decltype的使用
template<typename Container, typename Index>  // 正确但需要优化 
auto authAndAccess(Container& c, Index i) -> decltype(c[i]) { 
    authenticateUser(); 
    return c[i]; 
}

template<typename Container, typename Index> // C++11最终版本 
auto authAndAccess(Container&& c, Index i) -> decltype(std::forward<Container>(c)[i])  { 
    authenticateUser();
    return std::forward<Container>(c)[i]; 
}

template<typename Container, typename Index> // C++14最终版本 
decltype(auto) authAndAccess(Container&& c, Index i) {
     authenticateUser();
     return std::forward<Container>(c)[i];
}
```

`decltype((var))` 的结果为引用（双层括号）。

### 17. 顶层const和底层const

**顶层const** 表示const所修饰的对象是常量

**底层const** 表示指针所指的对象是一个常量或用于声明引用（底层const与指针和引用等复合类型的基本类型部分有关）

```c++
int i = 0;
int *const p1 = &i;		//顶层const，p1是一个常量指针
const int ci = 42;		//顶层const，ci是一个常量
const int *p2 = &ci;	//底层const，p2是指向常量的指针
const int *const p3 = p2;	//第一个const是底层const，第二个const是顶层const
const int &r = ci;		//用于声明引用的const都是底层const
```



​                                                                                                       

